---
title: "Sudan CMAM Dashboard"
runtime: shiny
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: scroll
    #social: [ "twitter", "linkedin" ]
    source_code: https://github.com/katilingban/sudanCMAM
    theme: cerulean
---

```{r setup, include = FALSE}
if(!require(flexdashboard)) install.packages("flexdashboard")
if(!require(ggplot2)) install.packages("ggplot2")
if(!require(tidyr)) install.packages("tidyr")
if(!require(magrittr)) install.packages("magrittr")
if(!require(plotly)) install.packages("plotly")
if(!require(lubridate)) install.packages("lubridate")
if(!require(leaflet)) install.packages("leaflet")
if(!require(RColorBrewer)) install.packages("RColorBrewer")
if(!require(remotes)) install.packages("remotes")
if(!require(squeacr)) remotes::install_github(repo = "rapidsurveys/squeacr")
if(!require(sudan)) remotes::install_github(repo = "spatialworks/sudan")

library(flexdashboard)
library(ggplot2)
library(tidyr)
library(magrittr)
library(plotly)
library(lubridate)
library(leaflet)
library(RColorBrewer)
library(remotes)
library(squeacr)
library(sudan)

## Create Mapbox base layer objects for leaflet mapping
mapbox.satellite <- "https://api.mapbox.com/styles/v1/mapbox/satellite-streets-v10/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1IjoiZXJuZXN0Z3VldmFycmEiLCJhIjoiejRRLXlZdyJ9.sqS1zi0rDH5CIzvcn9SXSg"
mapbox.street    <- "https://api.mapbox.com/styles/v1/mapbox/streets-v10/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1IjoiZXJuZXN0Z3VldmFycmEiLCJhIjoiejRRLXlZdyJ9.sqS1zi0rDH5CIzvcn9SXSg"
mapbox.dark      <- "https://api.mapbox.com/styles/v1/mapbox/dark-v9/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1IjoiZXJuZXN0Z3VldmFycmEiLCJhIjoiejRRLXlZdyJ9.sqS1zi0rDH5CIzvcn9SXSg"
mapbox.light     <- "https://api.mapbox.com/styles/v1/mapbox/light-v9/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1IjoiZXJuZXN0Z3VldmFycmEiLCJhIjoiejRRLXlZdyJ9.sqS1zi0rDH5CIzvcn9SXSg"
mapbox.moonlight <- "https://api.mapbox.com/styles/v1/ernestguevarra/cj3nban30001z2rpahc10c9ef/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1IjoiZXJuZXN0Z3VldmFycmEiLCJhIjoiejRRLXlZdyJ9.sqS1zi0rDH5CIzvcn9SXSg"
mapbox.northstar <- "https://api.mapbox.com/styles/v1/ernestguevarra/cj4ke832y4sng2spe2ds4fs55/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1IjoiZXJuZXN0Z3VldmFycmEiLCJhIjoiejRRLXlZdyJ9.sqS1zi0rDH5CIzvcn9SXSg"
mapbox.standard  <- "https://api.mapbox.com/styles/v1/ernestguevarra/cj5di36jn0gxg2rphjn3yetpt/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1IjoiZXJuZXN0Z3VldmFycmEiLCJhIjoiejRRLXlZdyJ9.sqS1zi0rDH5CIzvcn9SXSg"
mapbox.decimal   <- "https://api.mapbox.com/styles/v1/ernestguevarra/cj5ms1akt3pbi2smtcewsex9m/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1IjoiZXJuZXN0Z3VldmFycmEiLCJhIjoiejRRLXlZdyJ9.sqS1zi0rDH5CIzvcn9SXSg"
mapbox.terminal  <- "https://api.mapbox.com/styles/v1/ernestguevarra/cj6g0tzbd30kc2sph2wyh666m/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1IjoiZXJuZXN0Z3VldmFycmEiLCJhIjoiejRRLXlZdyJ9.sqS1zi0rDH5CIzvcn9SXSg"
mapbox.leshine  <- "https://api.mapbox.com/styles/v1/ernestguevarra/cjdlr8pvl0xiv2sqvq1evk1pl/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1IjoiZXJuZXN0Z3VldmFycmEiLCJhIjoiejRRLXlZdyJ9.sqS1zi0rDH5CIzvcn9SXSg"

## Load UNICEF palette
unicef_blue      <- "#1CABE2"
unicef_darkgreen <- "#00833D"
unicef_green     <- "#80BD41"
unicef_yellow    <- "#FFC20E"
unicef_orange    <- "#F26A21"
unicef_red       <- "#E2231A"
unicef_darkred   <- "#961A49" 
unicef_purple    <- "#6A1E74"
unicef_warmgrey  <- "#D8D1C9"
unicef_coolgrey  <- "#777779"
unicef_black     <- "#2D2926"
unicef_darkblue  <- "#374EA2"

## UNICEF ggplot theme settings
unicef_theme <- theme_bw() +
  theme(plot.title = element_text(size = 16, colour = unicef_darkblue),
        plot.subtitle = element_text(size = 14, colour = unicef_blue),
        panel.border = element_rect(colour = unicef_darkblue,
                                    size = 0.5),
        panel.grid.major = element_line(linetype = 0),
        panel.grid.minor = element_line(linetype = 0),
        strip.background = element_rect(colour = unicef_darkblue,
                                        fill = unicef_darkblue),
        strip.text = element_text(face = "bold", colour = "white", size = 10, vjust = 1),
        legend.background = element_rect(colour = NA, fill = NA),
        legend.key = element_rect(linetype = 0),
        legend.key.size = unit(x = 8, units = "points"),
        legend.spacing = unit(x = 4, units = "points"),
        legend.text = element_text(size =  8),
        legend.position = "top",
        axis.line.x = element_line(colour = unicef_darkblue, size = 0.5),
        axis.text.x = element_text(size = 10, colour = unicef_darkblue),
        axis.title.x = element_text(size = 12, colour = unicef_blue),
        axis.text.y = element_text(size = 10, colour = unicef_darkblue),
        axis.title.y = element_text(size = 12, colour = unicef_blue),
        axis.ticks = element_line(colour = unicef_darkblue, size = 0.25))

## Katilingban theme
katilingban_theme <- theme_bw() +
  theme(panel.border = element_rect(colour = "gray50",
                                    size = 0.5),
        panel.grid.major = element_line(linetype = 1,
                                        size = 0.1,
                                        colour = "gray90"),
        panel.grid.minor = element_line(linetype = 0),
        strip.background = element_rect(colour = "gray50",
                                        fill = "gray70"),
        strip.text = element_text(colour = "white", size = 12),
        legend.text = element_text(size = 12),
        legend.key = element_rect(linetype = 0),
        legend.key.size = unit(0.5, "cm"),
        legend.position = "top",
        axis.title = element_text(size = 12),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.ticks = element_line(colour = "gray50", size = 0.5))

legend.format <- function (prefix = "", 
                           suffix = "", 
                           between = " &ndash; ", 
                           digits = 3, 
                           big.mark = ",", 
                           transform = identity) {
  formatNum <- function(x) {
    format(round(transform(x), digits), trim = TRUE, 
           scientific = FALSE, big.mark = big.mark)
  }
    function(type, ...) {
        switch(type, numeric = (function(cuts) {
            paste0(prefix, formatNum(cuts), suffix)
        })(...), bin = (function(cuts) {
            n = length(cuts)
            paste0(prefix, formatNum(cuts[-n]), between, formatNum(cuts[-1]), 
                suffix)
        })(...), quantile = (function(cuts, p) {
            n = length(cuts)
            p = paste0(round(p * 100), "%")
            cuts = paste0(formatNum(cuts[-n]), between, formatNum(cuts[-1]), suffix)
        })(...), factor = (function(cuts) {
            paste0(prefix, as.character(transform(cuts)), suffix)
        })(...))
    }
}
```

Sidebar {.sidebar}
================================================================================

```{r}
div(style="display: inline-block;vertical-align:middle;",            
    h4("General settings"))

div(style="display: inline-block;vertical-align:top;",
    actionLink(inputId = "general_settings_info",
               label = "",
               icon = icon(name = "info-sign", lib = "glyphicon")))

observeEvent(input$general_settings_info, {
  showModal(
    modalDialog(
      HTML(
        "<p>These settings are used across the both sections (<strong>performance</strong> 
        and <strong>responsiveness</strong>) of this dashboard.</p>
        <br>
        <h4>Select state</h4>
        <p>From the drop-down menu, select the state for which state-specific analysis
        and/or visualisations are to be shown such as <strong>performance over 
        time from 2016-2019</strong>, <strong>admissions over time from 2016-2019</strong>
        and <strong>defaulters over time from 2016-2019</strong>.</p>
        <p>Selected state will also determine which localities are provided as
        options in the <em>Select locality</em> settings and which localities
        are presented in the locality level <strong>performance over time for a 
        specific year</strong>, <strong>admissions over time for a specific
        year</strong>, <strong>defaulters over time for a specific year</strong>
        and <strong>choropleth map of performance for a specific month and year</strong>.</p>
        <p>Click on drop-down menu to see list of states and select state. Gazera
        state is selected on dashboard startup.</p>
        <br>
        <h4>Select locality</h4>
        <p>From the drop-down menu, select the locality for which locality-specific
        analysis and/or visualisations are to be shown such as <strong>performance
        over time from 2016-2019</strong>, <strong>admissions over time from
        2016-2019</strong> and <strong>defaulters over time from 2016-2019</strong>.</p>
        <p>The list of localities to choose from the drop-down menu depends on
        the selected state. No locality is selected on dashboard startup.</p>
        <br>
        <h4>Select year</h4>
        <p>From the drop-down menu, select the year for which year-specific analysis
        and/or visualisations are to be shown such as <strong>performance over
        time at national, state and locality level</strong>, <strong>admissions
        over time at national, state and locality level</strong>,
        <strong>defaulters over time at national, state and locality level</strong>,
        and <strong>choropleth map of performance by selected month and year</strong>.
        <p>Click on the drop-down menu to see the choices of years from 2016 to
        2019. On dashboard startup, year 2016 is selected.</p>
        "
      ),
      title = "General settings",
      footer = modalButton("Close")
    )
  )
})

selectInput(inputId = "state_name",
            label = "Select state",
            choices = unique(monitoring$State),
            selected = NULL)

output$select_locality <- renderUI({
  req(input$state_name)
  selectInput(inputId = "locality_name",
              label = "Select locality",
              choices = unique(monitoring$Locality[monitoring$State == input$state_name]),
              selected = NULL)
})

uiOutput("select_locality")

selectInput(inputId = "chosen_year",
            label = "Select year",
            choices = unique(monitoring$Year),
            selected = NULL)

hr()
```

```{r}
div(style="display: inline-block;vertical-align:middle;",            
    h4("Performance settings"))

div(style="display: inline-block;vertical-align:top;",
    actionLink(inputId = "performance_settings_info",
               label = "",
               icon = icon(name = "info-sign", lib = "glyphicon")))

observeEvent(input$performance_settings_info, {
  showModal(
    modalDialog(
      HTML(
        "<p>These settings are used for the <strong>performance indicators</strong>
        section of this dashboard.</p>
        <br>
        <h4>Show Sphere standards</h4>
        <p>This checkbox indicates whether 
        <a href='https://handbook.spherestandards.org/en/sphere/#ch007' target='_blank'>Sphere standards</a> 
        for <strong> performance indicators</strong> should be shown on the plots.</p>
        <p>On dashboard startup, the checkbox is unchecked and performance indicator 
        values for 
        <a href='https://handbook.spherestandards.org/en/sphere/#ch007' target='_blank'>Sphere standards</a> 
        are not shown on the plots.</p>
        "
      ),
      title = "Performance settings",
      footer = modalButton("Close")
    )
  )
})

checkboxInput(inputId = "standards",
              label = "Show Sphere standards",
              value = FALSE)

hr()
#br()
```

```{r}
div(style="display: inline-block;vertical-align:middle;",            
    h4("Spatial settings"))

div(style="display: inline-block;vertical-align:top;",
    actionLink(inputId = "spatial_settings_info",
               label = "",
               icon = icon(name = "info-sign", lib = "glyphicon")))

observeEvent(input$spatial_settings_info, {
  showModal(
    modalDialog(
      HTML(
        "<p>These settings are used for the <strong>spatial</strong> outputs of 
        this dashboard.</p>
        <br>
        <h4>Select month</h4>
        <p>From the drop-down menu, select the month for selected performance 
        indicators are to be mapped.</p>
        <p>Click on the drop-down menu to see the choices of months from January to
        December. On dashboard startup, January is selected.</p>
        <br>
        <h4>Select indicator to map</h4>
        <p>From the drop-down menu, select the performance indicator to be mapped.</p>
        <p>Click on the drop-down menu to see the choices of performance indicators 
        from <strong>cured</strong>, <strong>defaulted</strong>,
        <strong>dead</strong> or <strong>non-responder</strong>. On dashboard 
        startup, <strong>cured</strong> is selected.</p>
        <br>
        <h4>Select map background</h4>
        <p>From the drop-down menu, select the map baselayer to use.</p>
        <p>Click on the drop-down menu to see the choices of 10 map baselayers
        from <a href='https://www.mapbox.com' target='_blank'>Mapbox</a>. On dashboard 
        startup, <strong>Terminal</strong> is selected.</p>    
        "
      ),
      title = "Spatial settings",
      footer = modalButton("Close")
    )
  )
})

selectInput(inputId = "chosen_month",
            label = "Select month",
            choices = c("January" = "Jan",
                        "February" = "Feb",
                        "March" = "Mar",
                        "April" = "Apr",
                        "May" = "May",
                        "June" = "Jun",
                        "July" = "Jul",
                        "August" = "Aug",
                        "September" = "Sep",
                        "October" = "Oct",
                        "November" = "Nov",
                        "December" = "Dec"),
            selected = NULL)

selectInput(inputId = "indicator",
            label = "Select indicator to map",
            choices = c("Performance: Cured" = "cured_perc",
                        "Performance: Defaulted" = "defaulted_perc",
                        "Performance: Dead" = "dead_perc",
                        "Performance: Non-responder" = "nonresponder_perc"),
            selected = NULL)

selectInput(inputId = "map_tiles",
            label = "Select map background",
            choices = c("Terminal" = "mapbox.terminal",
                        "Le Shine" = "mapbox.leshine",
                        "Satellite" = "mapbox.satellite",
                        "Street" = "mapbox.street",
                        "Dark" = "mapbox.dark",
                        "Light" = "mapbox.light",
                        "Moonlight" = "mapbox.moonlight",
                        "Northstar" = "mapbox.northstar",
                        "Standard" = "mapbox.standard",
                        "Decmial" = "mapbox.decimal"),
            selected = "map.terminal")

hr()
#br()
```

```{r}
div(style="display: inline-block;vertical-align:middle;",            
    h4("Responsiveness settings"))

div(style="display: inline-block;vertical-align:top;",
    actionLink(inputId = "responsiveness_settings_info",
               label = "",
               icon = icon(name = "info-sign", lib = "glyphicon")))

observeEvent(input$responsiveness_settings_info, {
  showModal(
    modalDialog(
      HTML(
        "<p>These settings are used for the <strong>responsiveness indicators</strong>
        section of this dashboard.</p>
        <br>
        <h4>Smooth line</h4>
        <p>This checkbox indicates whether the <strong>responsiveness indicators</strong>
        time series plot should be smoothed using the <strong>median of 3 and 
        average of 3</strong> approach.</p>
        <p>On dashboard startup, the checkbox is unchecked and smoothed line 
        for the time series is not shown on the plots.</p>
        <br>
        <h4>Show seasonal calendar</h4>
        <p>This checkbox indicates whether <strong>seasonal calendar</strong> should 
        be shown on the plots.</p>
        <p>On dashboard startup, the checkbox is unchecked and <strong>seasonal calendar</strong>
        is not shown on the plots.</p>
        <br>
        <h4>Scaling for plots</h4>
        <p>From the drop-down menu, select the type of <strong>y-axis scale</strong> 
        to use for responsiveness time series plots.</p>
        <p>Click on the drop-down menu to see the choice between <strong>Free</strong>
        and <strong>Fixed</strong>. Select <strong>Free</strong> to make
        <strong>y-axis scale</strong> of mutli-faceted plots indpendent of each other.
        This is good for examining time series trend for each state or for each
        locality. Select <strong>Fixed</strong> to make <strong>y-axis scale</strong>
        of mutli-faceted plots the same for each plot. This is good for comparing
        the magnitude of values of the time series plots between states or between
        localities. On dashboard startup, <strong>Free</strong> is selected.</p>
        "
      ),
      title = "Responsiveness settings",
      footer = modalButton("Close")
    )
  )
})

checkboxInput(inputId = "smooth",
              label = "Smooth line",
              value = FALSE)

checkboxInput(inputId = "showCalendar",
              label = "Show seasonal calendar",
              value = FALSE)

selectInput(inputId = "scales",
            label = "Scaling for plots",
            choices = c("Free" = "free_y",
                        "Fixed" = "fixed"),
            selected = "free_y")
```

Performance
================================================================================

Row {.tabset .tabset-fade}
--------------------------------------------------------------------------------

### National

```{r, fig.height = 5}
xOverall <- reactive({
  aggregate(cbind(Cured, Death, Default, `Non-Responder`) ~ Month + Year, 
            data = monitoring, FUN = sum) %>% 
    calculate_performance() %>%
    mutate(`Cured %` = cured_prop * 100,
           `Defaulted %` = defaulter_prop * 100,
           `Dead %` = dead_prop * 100,
           `Non-responder %` = nr_prop * 100,
           MonthYear = paste(Month, Year, sep = " "),
           MonthYear = factor(x = MonthYear, 
                              levels = c(paste(month.abb, "2016"),
                                         paste(month.abb, "2017"),
                                         paste(month.abb, "2018"),
                                         paste(month.abb, "2019"))))
})

output$performanceOverall <- renderPlotly({
  z <- xOverall() %>% 
    ggplot(mapping = aes(x = MonthYear, group = 1)) +
    geom_line(mapping = aes(y = `Cured %`, colour = "Cured",
                            text = paste("Cured: ", 
                                         round(`Cured %`, 
                                               digits = 1), "%\n",
                                         MonthYear, sep = "")), 
              size = 1) +
    geom_line(mapping = aes(y = `Dead %`, colour = "Dead",
                            text = paste("Dead: ",
                                         round(`Dead %`, 
                                               digits = 1), "%\n",
                                         MonthYear, sep = "")), 
              size = 1) +
    geom_line(mapping = aes(y = `Defaulted %`, colour = "Defaulted",
                            text = paste("Defaulted: ", 
                                         round(`Defaulted %`,
                                               digits = 1), "%\n", 
                                         MonthYear, sep = "")), 
              size = 1) +
    geom_line(mapping = aes(y = `Non-responder %`, colour = "Non-responder",
                            text = paste("Non-responder: ",
                                         round(`Non-responder %`,
                                               digits = 1), "%\n", 
                                         MonthYear, sep = "")), 
              alpha = 0.5, size = 1) +
    scale_colour_manual(name = "",
                        values = c("Cured" = "darkgreen", 
                                   "Dead" = "black", 
                                   "Defaulted" = "red", 
                                   "Non-responder" = "gray50")) +
    scale_y_continuous(limits = c(0, 100),
                                  breaks = seq(from = 0, to = 100, by = 10)) +
    labs(title = "National monthly performance over time - 2016 to 2019", 
         y = "%", 
         x = "")
  
  sphere_cure <- geom_hline(yintercept = 75, 
                            colour = "darkgreen", 
                            linetype = 2, size = 0.25)
  
  sphere_default <- geom_hline(yintercept = 15, 
                               colour = "red", 
                               linetype = 2, size = 0.25)
    
  sphere_dead <- geom_hline(yintercept = 10, 
                            colour = "black", 
                            linetype = 2, size = 0.25)
  
  ## Assemble plot
  if(input$standards) {
    z <- z + sphere_cure + sphere_default + sphere_dead + 
      unicef_theme +
      theme(axis.text.x = element_text(size = 8, angle = 90),
            axis.text.y = element_text(size = 8))
  } else {
    z <- z + 
      unicef_theme +
      theme(axis.text.x = element_text(size = 8, angle = 90),
            axis.text.y = element_text(size = 8))
  }
  
  ggplotly(p = z, tooltip = "text") %>%
    layout(legend = list(orientation = "h", y = 1.075))
})

plotlyOutput(outputId = "performanceOverall")
```

### State

```{r, fig.height = 5}
xStateOverall <- reactive({
  req(input$state_name)
  aggregate(cbind(Cured, Death, Default, `Non-Responder`) ~ State + Month + Year, 
            data = monitoring, FUN = sum) %>% 
    calculate_performance() %>%
    filter(State == input$state_name) %>%
    mutate(`Cured %` = cured_prop * 100,
           `Defaulted %` = defaulter_prop * 100,
           `Dead %` = dead_prop * 100,
           `Non-responder %` = nr_prop * 100,
           MonthYear = paste(Month, Year, sep = " "),
           MonthYear = factor(x = MonthYear, 
                              levels = c(paste(month.abb, "2016"),
                                         paste(month.abb, "2017"),
                                         paste(month.abb, "2018"),
                                         paste(month.abb, "2019"))))
})

output$performanceStateOverall <- renderPlotly({
  req(input$state_name)
  z <- xStateOverall() %>% 
    ggplot(mapping = aes(x = MonthYear, group = State)) +
    geom_line(mapping = aes(y = `Cured %`, colour = "Cured",
                            text = paste("Cured: ", 
                                         round(`Cured %`, 
                                               digits = 1), "%\n",
                                         MonthYear, sep = "")), 
              size = 1) +
    geom_line(mapping = aes(y = `Dead %`, colour = "Dead",
                            text = paste("Dead: ",
                                         round(`Dead %`, 
                                               digits = 1), "%\n",
                                         MonthYear, sep = "")), 
              size = 1) +
    geom_line(mapping = aes(y = `Defaulted %`, colour = "Defaulted",
                            text = paste("Defaulted: ", 
                                         round(`Defaulted %`,
                                               digits = 1), "%\n", 
                                         MonthYear, sep = "")), 
              size = 1) +
    geom_line(mapping = aes(y = `Non-responder %`, colour = "Non-responder",
                            text = paste("Non-responder: ",
                                         round(`Non-responder %`,
                                               digits = 1), "%\n", 
                                         MonthYear, sep = "")), 
              alpha = 0.5, size = 1) +
    scale_colour_manual(name = "",
                        values = c("Cured" = "darkgreen", 
                                   "Dead" = "black", 
                                   "Defaulted" = "red", 
                                   "Non-responder" = "gray50")) +
    scale_y_continuous(limits = c(0, 100),
                                  breaks = seq(from = 0, to = 100, by = 10)) +
    labs(title = paste(input$state_name, 
                       " State monthly performance over time - 2016 to 2019", 
                       sep = ""),
         y = "%", 
         x = "")
  
  sphere_cure <- geom_hline(yintercept = 75, 
                            colour = "darkgreen", 
                            linetype = 2, size = 0.25)
  
  sphere_default <- geom_hline(yintercept = 15, 
                               colour = "red", 
                               linetype = 2, size = 0.25)
    
  sphere_dead <- geom_hline(yintercept = 10, 
                            colour = "black", 
                            linetype = 2, size = 0.25)
  
  ## Assemble plot
  if(input$standards) {
    z <- z + sphere_cure + sphere_default + sphere_dead + 
      unicef_theme +
      theme(axis.text.x = element_text(size = 8, angle = 90),
            axis.text.y = element_text(size = 8))
  } else {
    z <- z + 
      unicef_theme +
      theme(axis.text.x = element_text(size = 8, angle = 90),
            axis.text.y = element_text(size = 8))
  }
  
  ggplotly(p = z, tooltip = "text") %>%
    layout(legend = list(orientation = "h", y = 1.075))
})

plotlyOutput(outputId = "performanceStateOverall")
```

### Locality

```{r, fig.height = 5}
xLocalityOverall <- reactive({
  req(input$state_name, input$locality_name)
  monitoring %>% 
    calculate_performance() %>%
    filter(State == input$state_name,
           Locality == input$locality_name) %>%
    mutate(`Cured %` = cured_prop * 100,
           `Defaulted %` = defaulter_prop * 100,
           `Dead %` = dead_prop * 100,
           `Non-responder %` = nr_prop * 100,
           MonthYear = paste(Month, Year, sep = " "),
           MonthYear = factor(x = MonthYear, 
                              levels = c(paste(month.abb, "2016"),
                                         paste(month.abb, "2017"),
                                         paste(month.abb, "2018"),
                                         paste(month.abb, "2019"))))
})

output$performanceLocalityOverall <- renderPlotly({
  req(xLocalityOverall(), input$locality_name)
  z <- xLocalityOverall() %>% 
    ggplot(mapping = aes(x = MonthYear, group = State)) +
    geom_line(mapping = aes(y = `Cured %`, colour = "Cured",
                            text = paste("Cured: ", 
                                         round(`Cured %`, 
                                               digits = 1), "%\n",
                                         MonthYear, sep = "")), 
              size = 1) +
    geom_line(mapping = aes(y = `Dead %`, colour = "Dead",
                            text = paste("Dead: ",
                                         round(`Dead %`, 
                                               digits = 1), "%\n",
                                         MonthYear, sep = "")), 
              size = 1) +
    geom_line(mapping = aes(y = `Defaulted %`, colour = "Defaulted",
                            text = paste("Defaulted: ", 
                                         round(`Defaulted %`,
                                               digits = 1), "%\n", 
                                         MonthYear, sep = "")), 
              size = 1) +
    geom_line(mapping = aes(y = `Non-responder %`, colour = "Non-responder",
                            text = paste("Non-responder: ",
                                         round(`Non-responder %`,
                                               digits = 1), "%\n", 
                                         MonthYear, sep = "")), 
              alpha = 0.5, size = 1) +
    scale_colour_manual(name = "",
                        values = c("Cured" = "darkgreen", 
                                   "Dead" = "black", 
                                   "Defaulted" = "red", 
                                   "Non-responder" = "gray50")) +
    scale_y_continuous(limits = c(0, 100),
                                  breaks = seq(from = 0, to = 100, by = 10)) +
    labs(title = paste(input$locality_name, " Locality, ",
                       input$state_name, 
                       " State monthly performance over time - 2016 to 2019"),
         y = "%", 
         x = "")
  
  sphere_cure <- geom_hline(yintercept = 75, 
                            colour = "darkgreen", 
                            linetype = 2, size = 0.25)
  
  sphere_default <- geom_hline(yintercept = 15, 
                               colour = "red", 
                               linetype = 2, size = 0.25)
    
  sphere_dead <- geom_hline(yintercept = 10, 
                            colour = "black", 
                            linetype = 2, size = 0.25)
  
  ## Assemble plot
  if(input$standards) {
    z <- z + sphere_cure + sphere_default + sphere_dead + 
      unicef_theme +
      theme(axis.text.x = element_text(size = 8, angle = 90),
            axis.text.y = element_text(size = 8))
  } else {
    z <- z + 
      unicef_theme +
      theme(axis.text.x = element_text(size = 8, angle = 90),
            axis.text.y = element_text(size = 8))
  }
  
  ggplotly(p = z, tooltip = "text") %>%
    layout(legend = list(orientation = "h", y = 1.075))
})

plotlyOutput(outputId = "performanceLocalityOverall")
```

Row {.tabset .tabset-fade}
--------------------------------------------------------------------------------

### National

```{r, fig.height = 8}
yearTotal <- reactive({
  aggregate(cbind(Cured, Death, Default, `Non-Responder`) ~ Year, 
            data = monitoring, FUN = sum) %>% 
    calculate_performance() %>%
    select(Year, cured_prop:nr_prop) %>%
    mutate(Cured = cured_prop * 100,
           Defaulted = defaulter_prop * 100,
           Dead = dead_prop * 100,
           `Non-responder` = nr_prop * 100) %>%
    pivot_longer(cols = Cured:`Non-responder`, 
                 names_to = "Indicator",
                 values_to = "Performance") %>%
    mutate(Indicator = factor(x = Indicator, 
                              levels = c("Cured", "Defaulted", 
                                         "Dead", "Non-responder")))
})

output$performanceYearOverall <- renderPlotly({
  z <- yearTotal() %>% 
    ggplot(mapping = aes(x = Year, y = Performance)) +
    geom_col(mapping = aes(fill = Indicator), 
             width = 0.5,
             alpha = 0.8) + 
    scale_fill_manual(name = "",
                      values = c("Cured" = "#1a9850", 
                                 "Defaulted" = "#d73027",
                                 "Dead" = "black", 
                                 "Non-responder" = "gray80")) +
    scale_y_continuous(limits = c(0, 100),
                                  breaks = seq(from = 0, to = 100, by = 10)) +
    labs(title = "National yearly performance over time - 2016 to 2019", 
         y = "%", 
         x = "")
  
  ## Assemble plot
  z <- z + unicef_theme
  
  ggplotly(p = z) %>%
    layout(legend = list(orientation = "h", y = 1.04))
})

plotlyOutput(outputId = "performanceYearOverall")
```

### State

```{r, fig.height = 5}
yearStateTotal <- reactive({
  req(input$state_name)
  aggregate(cbind(Cured, Death, Default, `Non-Responder`) ~ Year + State, 
            data = monitoring, FUN = sum) %>%
    calculate_performance() %>%
    select(Year:State, cured_prop:nr_prop) %>%
    mutate(Cured = cured_prop * 100,
           Defaulted = defaulter_prop * 100,
           Dead = dead_prop * 100,
           `Non-responder` = nr_prop * 100) %>%
    pivot_longer(cols = Cured:`Non-responder`, 
                 names_to = "Indicator",
                 values_to = "Performance") %>%
    mutate(Indicator = factor(x = Indicator, 
                              levels = c("Cured", "Defaulted", 
                                         "Dead", "Non-responder")))
})


output$performanceYearStateOverall <- renderPlotly({
  z <- yearStateTotal() %>%
    ggplot(mapping = aes(x = Year, y = Performance)) +
    geom_col(mapping = aes(fill = Indicator), 
             width = 0.5,
             alpha = 0.8) + 
    scale_fill_manual(name = "",
                      values = c("Cured" = "#1a9850", 
                                 "Defaulted" = "#d73027",
                                 "Dead" = "black", 
                                 "Non-responder" = "gray80")) +
    scale_y_continuous(limits = c(0, 100),
                                  breaks = seq(from = 0, to = 100, by = 10)) +
    labs(title = "National yearly performance by state over time - 2016 to 2019", 
         y = "%", 
         x = "")
  
  add_facets <- facet_wrap( ~ State, ncol = 6)
  
  ## Assemble plot
  z <- z + 
    add_facets + 
    unicef_theme +
    theme(axis.text.x = element_text(size = 8, angle = 90),
          axis.text.y = element_text(size = 8))
  
  ggplotly(p = z, tooltip = "text") %>%
    layout(legend = list(orientation = "h", y = -0.055))
})

plotlyOutput(outputId = "performanceYearStateOverall")
```

### Locality

```{r, fig.height = 5}
yearLocalityTotal <- reactive({
  req(input$state_name, input$locality_name)
  aggregate(cbind(Cured, Death, Default, `Non-Responder`) ~ Year + State + Locality, 
            data = monitoring, FUN = sum) %>%
    filter(State == input$state_name) %>%
    calculate_performance() %>%
    select(Year:Locality, cured_prop:nr_prop) %>%
    mutate(Cured = cured_prop * 100,
           Defaulted = defaulter_prop * 100,
           Dead = dead_prop * 100,
           `Non-responder` = nr_prop * 100) %>%
    pivot_longer(cols = Cured:`Non-responder`, 
                 names_to = "Indicator",
                 values_to = "Performance") %>%
    mutate(Indicator = factor(x = Indicator, 
                              levels = c("Cured", "Defaulted", 
                                         "Dead", "Non-responder")))
})

output$performanceYearLocalityOverall <- renderPlotly({
  z <- yearLocalityTotal() %>%
    ggplot(mapping = aes(x = Year, y = Performance)) +
    geom_col(mapping = aes(fill = Indicator), 
             width = 0.5,
             alpha = 0.8) + 
    scale_fill_manual(name = "",
                      values = c("Cured" = "#1a9850", 
                                 "Defaulted" = "#d73027",
                                 "Dead" = "black", 
                                 "Non-responder" = "gray80")) +
    scale_y_continuous(limits = c(0, 100),
                                  breaks = seq(from = 0, to = 100, by = 10)) +
    labs(title = "National yearly performance by locality over time - 2016 to 2019", 
         y = "%", 
         x = "")
  
  add_facets <- facet_wrap( ~ Locality, ncol = 3)
  
  ## Assemble plot
  z <- z + 
    add_facets + 
    unicef_theme +
    theme(axis.text.x = element_text(size = 8, angle = 90),
          axis.text.y = element_text(size = 8))
  
  ggplotly(p = z, tooltip = "text") %>%
    layout(legend = list(orientation = "h", y = -0.055))
})

plotlyOutput(outputId = "performanceYearLocalityOverall")
```

Row {.tabset .tabset-fade}
--------------------------------------------------------------------------------

### National

```{r, fig.height = 8}
x <- reactive({
  aggregate(cbind(Cured, Death, Default, `Non-Responder`) ~ Month + Year, 
            data = monitoring, FUN = sum) %>% 
    calculate_performance() %>%
    filter(Year == input$chosen_year) %>%
    mutate(`Cured %` = cured_prop * 100,
           `Defaulted %` = defaulter_prop * 100,
           `Dead %` = dead_prop * 100,
           `Non-responder %` = nr_prop * 100,
           Month = factor(x = Month, 
                          levels = month.abb))
})

output$performance <- renderPlotly({
  z <- x() %>% 
    ggplot(mapping = aes(x = Month, group = Year)) +
    geom_line(mapping = aes(y = `Cured %`, colour = "Cured",
                            text = paste("Cured: ", 
                                         round(`Cured %`, digits = 1),
                                         "%\n", Month, " ", Year, sep = "")), 
              size = 1) +
    geom_line(mapping = aes(y = `Dead %`, colour = "Dead",
                            text = paste("Dead: ",
                                         round(`Dead %`, digits = 1),
                                         "%\n", Month, " ", Year, sep = "")),
              size = 1) +
    geom_line(mapping = aes(y = `Defaulted %`, colour = "Defaulted",
                            text = paste("Defaulted: ",
                                         round(`Defaulted %`, digits = 1),
                                         "%\n", Month, " ", Year, sep = "")),
              size = 1) +
    geom_line(mapping = aes(y = `Non-responder %`, colour = "Non-responder",
                            text = paste("Non-responder: ",
                                         round(`Non-responder %`, digits = 1),
                                         "%\n", Month, " ", Year, sep = "")),
              alpha = 0.5, size = 1) +
    scale_colour_manual(name = "",
                        values = c("Cured" = "darkgreen", 
                                   "Dead" = "black", 
                                   "Defaulted" = "red", 
                                   "Non-responder" = "gray50")) +
    scale_y_continuous(limits = c(0, 100),
                                  breaks = seq(from = 0, to = 100, by = 10)) +
    labs(title = paste("Performance over time - Year ", input$chosen_year, sep = ""),
         y = "%", x = "")
  
  sphere_cure <- geom_hline(yintercept = 75, 
                            colour = "darkgreen", 
                            linetype = 2, size = 0.25)
  
  sphere_default <- geom_hline(yintercept = 15, 
                               colour = "red", 
                               linetype = 2, size = 0.25)
    
  sphere_dead <- geom_hline(yintercept = 10, 
                            colour = "black", 
                            linetype = 2, size = 0.25)
  
  ## Assemble plot
  if(input$standards) {
    z <- z + sphere_cure + sphere_default + sphere_dead + unicef_theme
  } else {
    z <- z + unicef_theme
  }
  
  ggplotly(p = z, tooltip = "text") %>%
    layout(legend = list(orientation = "h", y = 1.035))
})

plotlyOutput(outputId = "performance")
```

### State

```{r}
xstate <- reactive({
  aggregate(cbind(Cured, Death, Default, `Non-Responder`) ~ State + Month + Year, 
               data = monitoring, FUN = sum) %>% 
    calculate_performance() %>%
    filter(Year == input$chosen_year) %>%
    mutate(`Cured %` = cured_prop * 100,
           `Defaulted %` = defaulter_prop * 100,
           `Dead %` = dead_prop * 100,
           `Non-responder %` = nr_prop * 100,
           Month = factor(x = Month, 
                          levels = month.abb))
})

output$state_performance <- renderPlotly({
  z <- xstate() %>%
    ggplot(mapping = aes(x = Month, group = State)) +
    geom_line(mapping = aes(y = `Cured %`, colour = "Cured",
                            text = paste("Cured: ", 
                                         round(`Cured %`, digits = 1),
                                         "%\n", Month, " ", Year, sep = "")), 
              size = 1) +
    geom_line(mapping = aes(y = `Dead %`, colour = "Dead",
                            text = paste("Dead: ",
                                         round(`Dead %`, digits = 1),
                                         "%\n", Month, " ", Year, sep = "")),
              size = 1) +
    geom_line(mapping = aes(y = `Defaulted %`, colour = "Defaulted",
                            text = paste("Defaulted: ",
                                         round(`Defaulted %`, digits = 1),
                                         "%\n", Month, " ", Year, sep = "")),
              size = 1) +
    geom_line(mapping = aes(y = `Non-responder %`, colour = "Non-responder",
                            text = paste("Non-responder: ",
                                         round(`Non-responder %`, digits = 1),
                                         "%\n", Month, " ", Year, sep = "")),
              alpha = 0.5, size = 1) +
    scale_colour_manual(name = "",
                        values = c("Cured" = "darkgreen", 
                                   "Dead" = "black", 
                                   "Defaulted" = "red", 
                                   "Non-responder" = "gray50")) +
    scale_y_continuous(limits = c(0, 100),
                       breaks = seq(from = 0, to = 100, by = 10)) +
    labs(title = paste("Performance over time by state - Year ", input$chosen_year, sep = ""), 
         y = "%", x = "")
        
  sphere_cure <- geom_hline(yintercept = 75, 
                            colour = "darkgreen", 
                            linetype = 2, size = 0.25)
  
  sphere_default <- geom_hline(yintercept = 15, 
                               colour = "red", 
                               linetype = 2, size = 0.25)
    
  sphere_dead <- geom_hline(yintercept = 10, 
                            colour = "black", 
                            linetype = 2, size = 0.25)
  
  add_facets <- facet_wrap( ~ State, ncol = 6)

  if(input$standards) {
    z <- z + sphere_cure + sphere_default + sphere_dead + add_facets
  } else {
    z <- z + add_facets
  }

  z <- z + unicef_theme +
    theme(axis.text.x = element_text(size = 8, angle = 90),
          axis.text.y = element_text(size = 8))
  
  ggplotly(p = z, tooltip = "text") %>%
    layout(legend = list(orientation = "h", y = -0.055))
})

plotlyOutput(outputId = "state_performance")
```

### Locality

```{r}
xlocality <- reactive({
  monitoring %>% 
    calculate_performance() %>%
    filter(Year == input$chosen_year,
           State == input$state_name) %>%
    mutate(`Cured %` = cured_prop * 100,
           `Defaulted %` = defaulter_prop * 100,
           `Dead %` = dead_prop * 100,
           `Non-responder %` = nr_prop * 100,
           Month = factor(x = Month, 
                          levels = month.abb))
})

output$locality_performance <- renderPlotly({
  z <- xlocality() %>%
    ggplot(mapping = aes(x = Month, group = Locality)) +
    geom_line(mapping = aes(y = `Cured %`, colour = "Cured",
                            text = paste("Cured: ", 
                                         round(`Cured %`, digits = 1),
                                         "%\n", Month, " ", Year, sep = "")), 
              size = 1) +
    geom_line(mapping = aes(y = `Dead %`, colour = "Dead",
                            text = paste("Dead: ",
                                         round(`Dead %`, digits = 1),
                                         "%\n", Month, " ", Year, sep = "")),
              size = 1) +
    geom_line(mapping = aes(y = `Defaulted %`, colour = "Defaulted",
                            text = paste("Defaulted: ",
                                         round(`Defaulted %`, digits = 1),
                                         "%\n", Month, " ", Year, sep = "")),
              size = 1) +
    geom_line(mapping = aes(y = `Non-responder %`, colour = "Non-responder",
                            text = paste("Non-responder: ",
                                         round(`Non-responder %`, digits = 1),
                                         "%\n", Month, " ", Year, sep = "")),
              alpha = 0.5, size = 1) +
    scale_colour_manual(name = "",
                        values = c("Cured" = "darkgreen", 
                                   "Dead" = "black", 
                                   "Defaulted" = "red", 
                                   "Non-responder" = "gray50")) +
    scale_y_continuous(limits = c(0, 100),
                       breaks = seq(from = 0, to = 100, by = 10)) +
    labs(title = paste("Performance over time in ", input$state_name, 
                       " State by locality - Year ", input$chosen_year, sep = ""),
         y = "%", x = "")
    
  sphere_cure <- geom_hline(yintercept = 75, 
                            colour = "darkgreen", 
                            linetype = 2, size = 0.25)
  
  sphere_default <- geom_hline(yintercept = 15, 
                               colour = "red", 
                               linetype = 2, size = 0.25)
    
  sphere_dead <- geom_hline(yintercept = 10, 
                            colour = "black", 
                            linetype = 2, size = 0.25)
  
  add_facets <- facet_wrap( ~ Locality, nrow = 3)

  if(input$standards) {
    z <- z + sphere_cure + sphere_default + sphere_dead + add_facets
  } else {
    z <- z + add_facets
  }
  
  z <- z +
    unicef_theme +
    theme(axis.text.x = element_text(size = 8, angle = 90),
          axis.text.y = element_text(size = 8))
  
  ggplotly(p = z, tooltip = "text") %>%
    layout(legend = list(orientation = "h", y = -0.055))
})

plotlyOutput(outputId = "locality_performance")
```

Row
--------------------------------------------------------------------------------

### Map of performance by state for a given month and year

```{r, fig.height = 5}
output$statePerformanceMap <- renderLeaflet({
  leaflet()
})

observeEvent(input$map_tiles, {
  leafletProxy("statePerformanceMap") %>%
    addTiles(urlTemplate = get(input$map_tiles),
             attribution = "Map by <a href='http://www.mapbox.com/'>Mapbox</a>")
})

observeEvent(input$indicator, {
  xx <- aggregate(cbind(Cured, Death, Default, `Non-Responder`) ~ State + Month + Year, 
                  data = monitoring, FUN = sum) %>% 
    calculate_performance() %>%
    filter(Year == input$chosen_year,
           Month == input$chosen_month) %>%
    mutate(cured_perc = cured_prop * 100,
           defaulted_perc = defaulter_prop * 100,
           dead_perc = dead_prop * 100,
           nonresponder_perc = nr_prop * 100,
           Month = factor(x = Month, 
                          levels = month.abb))  
  
  state_map <- states
  state_map@data <- merge(state_map@data, xx, 
                          by.x = "State_En", 
                          by.y = "State",
                          all.x = TRUE)
  
  state_map@data <- state_map@data[order(as.numeric(state_map$OBJECTID_1)), ]
  
  if(input$indicator == "cured_perc") {
    indicator <- "Cured"
    mapPalette <- brewer.pal(n = 6, name = "RdYlGn")
    pal <- colorBin(palette = mapPalette,
                    domain = c(0, 100),
                    bins = c(0, 75, 80, 85, 90, 95, 100))
  } else {
    mapPalette <- brewer.pal(n = 5, name = "RdYlGn")
    
    if(input$indicator == "defaulted_perc") {
      indicator <- "Defaulted"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 1, 5, 10, 15, 100),
                      reverse = TRUE)
    }
    
    if(input$indicator == "dead_perc") {
      indicator <- "Dead"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 2, 5, 8, 10, 100),
                      reverse = TRUE)
    }  
  
    if(input$indicator == "nonresponder_perc") {
      indicator <- "Non-responder"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 2, 3, 4, 5, 100),
                      reverse = TRUE)
    }    
  }
  
  leafletProxy("statePerformanceMap") %>%
    clearControls() %>%
    clearShapes() %>%
    fitBounds(lng1 = bbox(state_map)[1, 1], lat1 = bbox(state_map)[2, 1],
              lng2 = bbox(state_map)[1, 2], lat2 = bbox(state_map)[2, 2]) %>%
    addPolygons(data = state_map,
                fillColor = pal(state_map[[input$indicator]]),
                weight = 2,
                opacity = 1,
                color = pal(state_map[[input$indicator]]),
                dashArray = "",
                fillOpacity = 0.8,
                highlight = highlightOptions(weight = 3,
                                             color = "#666",
                                             dashArray = "",
                                             fillOpacity = 0.7,
                                             bringToFront = TRUE),
                label = paste("<strong>", state_map[["State_En"]], 
                              " State</strong><br/><strong>", indicator,
                              ":</strong> ", 
                              round(state_map[[input$indicator]], digits = 2), 
                              "%<br/>", input$chosen_month, " ", 
                              input$chosen_year, sep = "") %>%
                  lapply(FUN = htmltools::HTML),
                labelOptions = labelOptions(style = list("font-weight" = "normal", 
                                                         padding = "3px 8px"),
                                            textsize = "12px",
                                            direction = "auto")) %>%
    addLegend(pal = pal, 
              values = c(0, 100),
              title = htmltools::HTML(
                paste(indicator, "<br/>", input$chosen_month, 
                      " ",  input$chosen_year, sep = "")),
              opacity = 0.7,
              position = "bottomright", 
              labFormat = legend.format(digits = 1, between = " to ", suffix = "%"),
              layerId = "legend")
})

observeEvent(input$chosen_month, {
  xx <- aggregate(cbind(Cured, Death, Default, `Non-Responder`) ~ State + Month + Year, 
                  data = monitoring, FUN = sum) %>% 
    calculate_performance() %>%
    filter(Year == input$chosen_year,
           Month == input$chosen_month) %>%
    mutate(cured_perc = cured_prop * 100,
           defaulted_perc = defaulter_prop * 100,
           dead_perc = dead_prop * 100,
           nonresponder_perc = nr_prop * 100,
           Month = factor(x = Month, 
                          levels = month.abb))  
  
  state_map <- states
  state_map@data <- merge(state_map@data, xx, 
                          by.x = "State_En", 
                          by.y = "State",
                          all.x = TRUE)
  
  state_map@data <- state_map@data[order(as.numeric(state_map$OBJECTID_1)), ]
  
  if(input$indicator == "cured_perc") {
    indicator <- "Cured"
    mapPalette <- brewer.pal(n = 6, name = "RdYlGn")
    pal <- colorBin(palette = mapPalette,
                    domain = c(0, 100),
                    bins = c(0, 75, 80, 85, 90, 95, 100))
  } else {
    mapPalette <- brewer.pal(n = 5, name = "RdYlGn")
    
    if(input$indicator == "defaulted_perc") {
      indicator <- "Defaulted"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 1, 5, 10, 15, 100),
                      reverse = TRUE)
    }
    
    if(input$indicator == "dead_perc") {
      indicator <- "Dead"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 2, 5, 8, 10, 100),
                      reverse = TRUE)
    }  
  
    if(input$indicator == "nonresponder_perc") {
      indicator <- "Non-responder"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 2, 3, 4, 5, 100),
                      reverse = TRUE)
    }    
  }
  
  leafletProxy("statePerformanceMap") %>%
    clearControls() %>%
    clearShapes() %>%
    fitBounds(lng1 = bbox(state_map)[1, 1], lat1 = bbox(state_map)[2, 1],
              lng2 = bbox(state_map)[1, 2], lat2 = bbox(state_map)[2, 2]) %>%
    addPolygons(data = state_map,
                fillColor = pal(state_map[[input$indicator]]),
                weight = 2,
                opacity = 1,
                color = pal(state_map[[input$indicator]]),
                dashArray = "",
                fillOpacity = 0.8,
                highlight = highlightOptions(weight = 3,
                                             color = "#666",
                                             dashArray = "",
                                             fillOpacity = 0.7,
                                             bringToFront = TRUE),
                label = paste("<strong>", state_map[["State_En"]], 
                              " State</strong><br/><strong>", indicator,
                              ":</strong> ", 
                              round(state_map[[input$indicator]], digits = 2), 
                              "%<br/>", input$chosen_month, " ", 
                              input$chosen_year, sep = "") %>%
                  lapply(FUN = htmltools::HTML),
                labelOptions = labelOptions(style = list("font-weight" = "normal", 
                                                         padding = "3px 8px"),
                                            textsize = "12px",
                                            direction = "auto")) %>%
    addLegend(pal = pal, 
              values = c(0, 100),
              title = htmltools::HTML(
                paste(indicator, "<br/>", input$chosen_month, 
                      " ",  input$chosen_year, sep = "")),
              opacity = 0.7,
              position = "bottomright", 
              labFormat = legend.format(digits = 1, between = " to ", suffix = "%"),
              layerId = "legend")
})

observeEvent(input$chosen_year, {
  xx <- aggregate(cbind(Cured, Death, Default, `Non-Responder`) ~ State + Month + Year, 
                  data = monitoring, FUN = sum) %>% 
    calculate_performance() %>%
    filter(Year == input$chosen_year,
           Month == input$chosen_month) %>%
    mutate(cured_perc = cured_prop * 100,
           defaulted_perc = defaulter_prop * 100,
           dead_perc = dead_prop * 100,
           nonresponder_perc = nr_prop * 100,
           Month = factor(x = Month, 
                          levels = month.abb))  
  
  state_map <- states
  state_map@data <- merge(state_map@data, xx, 
                          by.x = "State_En", 
                          by.y = "State",
                          all.x = TRUE)
  
  state_map@data <- state_map@data[order(as.numeric(state_map$OBJECTID_1)), ]
  
  if(input$indicator == "cured_perc") {
    indicator <- "Cured"
    mapPalette <- brewer.pal(n = 6, name = "RdYlGn")
    pal <- colorBin(palette = mapPalette,
                    domain = c(0, 100),
                    bins = c(0, 75, 80, 85, 90, 95, 100))
  } else {
    mapPalette <- brewer.pal(n = 5, name = "RdYlGn")
    
    if(input$indicator == "defaulted_perc") {
      indicator <- "Defaulted"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 1, 5, 10, 15, 100),
                      reverse = TRUE)
    }
    
    if(input$indicator == "dead_perc") {
      indicator <- "Dead"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 2, 5, 8, 10, 100),
                      reverse = TRUE)
    }  
  
    if(input$indicator == "nonresponder_perc") {
      indicator <- "Non-responder"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 2, 3, 4, 5, 100),
                      reverse = TRUE)
    }    
  }
  
  leafletProxy("statePerformanceMap") %>%
    clearControls() %>%
    clearShapes() %>%
    fitBounds(lng1 = bbox(state_map)[1, 1], lat1 = bbox(state_map)[2, 1],
              lng2 = bbox(state_map)[1, 2], lat2 = bbox(state_map)[2, 2]) %>%
    addPolygons(data = state_map,
                fillColor = pal(state_map[[input$indicator]]),
                weight = 2,
                opacity = 1,
                color = pal(state_map[[input$indicator]]),
                dashArray = "",
                fillOpacity = 0.8,
                highlight = highlightOptions(weight = 3,
                                             color = "#666",
                                             dashArray = "",
                                             fillOpacity = 0.7,
                                             bringToFront = TRUE),
                label = paste("<strong>", state_map[["State_En"]], 
                              " State</strong><br/><strong>", indicator,
                              ":</strong> ", 
                              round(state_map[[input$indicator]], digits = 2), 
                              "%<br/>", input$chosen_month, " ", 
                              input$chosen_year, sep = "") %>%
                  lapply(FUN = htmltools::HTML),
                labelOptions = labelOptions(style = list("font-weight" = "normal", 
                                                         padding = "3px 8px"),
                                            textsize = "12px",
                                            direction = "auto")) %>%
    addLegend(pal = pal, 
              values = c(0, 100),
              title = htmltools::HTML(
                paste(indicator, "<br/>", input$chosen_month, 
                      " ",  input$chosen_year, sep = "")),
              opacity = 0.7,
              position = "bottomright", 
              labFormat = legend.format(digits = 1, between = " to ", suffix = "%"),
              layerId = "legend")
})

leafletOutput(outputId = "statePerformanceMap")
```

### Map of performance by locality for a given state, month and year

```{r, fig.height = 5, eval = TRUE}
output$localityPerformanceMap <- renderLeaflet({
  leaflet()
})

observeEvent(input$map_tiles, {
  leafletProxy("localityPerformanceMap") %>%
    addTiles(urlTemplate = get(input$map_tiles),
             attribution = "Map by <a href='http://www.mapbox.com/'>Mapbox</a>")
})

observeEvent(input$indicator, {
  xx <- monitoring %>% 
    filter(Year == input$chosen_year,
           Month == input$chosen_month,
           State == input$state_name) %>%
    calculate_performance() %>%
    mutate(cured_perc = cured_prop * 100,
           defaulted_perc = defaulter_prop * 100,
           dead_perc = dead_prop * 100,
           nonresponder_perc = nr_prop * 100,
           Month = factor(x = Month, 
                          levels = month.abb))  
  
  locality_map <- localities
  locality_map <- subset(locality_map, State_En == input$state_name)
  locality_map@data <- merge(locality_map@data, xx, 
                             by.x = "Name_Engli", 
                             by.y = "Locality",
                             all.x = TRUE)
    
  locality_map@data <- locality_map@data[order(as.numeric(locality_map$OBJECTID)), ]

  if(input$indicator == "cured_perc") {
    indicator <- "Cured"
    mapPalette <- brewer.pal(n = 6, name = "RdYlGn")
    pal <- colorBin(palette = mapPalette,
                    domain = c(0, 100),
                    bins = c(0, 75, 80, 85, 90, 95, 100))
  } else {
    mapPalette <- brewer.pal(n = 5, name = "RdYlGn")
    
    if(input$indicator == "defaulted_perc") {
      indicator <- "Defaulted"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 1, 5, 10, 15, 100),
                      reverse = TRUE)
    }
    
    if(input$indicator == "dead_perc") {
      indicator <- "Dead"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 2, 5, 8, 10, 100),
                      reverse = TRUE)
    }  
  
    if(input$indicator == "nonresponder_perc") {
      indicator <- "Non-responder"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 2, 3, 4, 5, 100),
                      reverse = TRUE)
    }    
  }
  
  lab <- paste(round(locality_map[[input$indicator]], digits = 2), 
               "%<br>", sep = "")
  
  lab[is.nan(locality_map[[input$indicator]])] <- "No discharges<br>"
  
  lab[!is.nan(locality_map[[input$indicator]]) & is.na(locality_map[[input$indicator]])] <- "No data<br>"
  
  leafletProxy("localityPerformanceMap") %>%
    clearControls() %>%
    clearShapes() %>%
    fitBounds(lng1 = bbox(locality_map)[1, 1], lat1 = bbox(locality_map)[2, 1],
              lng2 = bbox(locality_map)[1, 2], lat2 = bbox(locality_map)[2, 2]) %>%
    addPolygons(data = locality_map,
                fillColor = pal(locality_map[[input$indicator]]),
                weight = 2,
                opacity = 1,
                color = pal(locality_map[[input$indicator]]),
                dashArray = "",
                fillOpacity = 0.8,
                highlight = highlightOptions(weight = 3,
                                             color = "#666",
                                             dashArray = "",
                                             fillOpacity = 0.7,
                                             bringToFront = TRUE),
                label = paste("<strong>", locality_map[["Name_Engli"]], 
                              " Locality</strong><br/><strong>", 
                              locality_map[["State_En"]], 
                              " State</strong><br/><strong>", indicator,
                              ":</strong> ", 
                              lab, input$chosen_month, " ", 
                              input$chosen_year, sep = "") %>%
                  lapply(FUN = htmltools::HTML),
                labelOptions = labelOptions(style = list("font-weight" = "normal", 
                                                         padding = "3px 8px"),
                                            textsize = "12px",
                                            direction = "auto")) %>%
    addLegend(pal = pal, 
              values = c(0, 100),
              title = htmltools::HTML(
                paste(indicator, "<br/>", 
                      input$state_name, " State<br/>",
                      input$chosen_month, 
                      " ",  input$chosen_year, sep = "")),
              opacity = 0.7,
              position = "bottomright", 
              labFormat = legend.format(digits = 1, between = " to ", suffix = "%"),
              layerId = "legend")
})

observeEvent(input$chosen_month, {
  xx <- monitoring %>% 
    filter(Year == input$chosen_year,
           Month == input$chosen_month,
           State == input$state_name) %>%
    calculate_performance() %>%
    mutate(cured_perc = cured_prop * 100,
           defaulted_perc = defaulter_prop * 100,
           dead_perc = dead_prop * 100,
           nonresponder_perc = nr_prop * 100,
           Month = factor(x = Month, 
                          levels = month.abb))  
  
  locality_map <- localities
  locality_map <- subset(locality_map, State_En == input$state_name)
  locality_map@data <- merge(locality_map@data, xx, 
                             by.x = "Name_Engli", 
                             by.y = "Locality",
                             all.x = TRUE)
    
  locality_map@data <- locality_map@data[order(as.numeric(locality_map$OBJECTID)), ]
    
  if(input$indicator == "cured_perc") {
    indicator <- "Cured"
    mapPalette <- brewer.pal(n = 6, name = "RdYlGn")
    pal <- colorBin(palette = mapPalette,
                    domain = c(0, 100),
                    bins = c(0, 75, 80, 85, 90, 95, 100))
  } else {
    mapPalette <- brewer.pal(n = 5, name = "RdYlGn")
    
    if(input$indicator == "defaulted_perc") {
      indicator <- "Defaulted"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 1, 5, 10, 15, 100),
                      reverse = TRUE)
    }
    
    if(input$indicator == "dead_perc") {
      indicator <- "Dead"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 2, 5, 8, 10, 100),
                      reverse = TRUE)
    }  
  
    if(input$indicator == "nonresponder_perc") {
      indicator <- "Non-responder"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 2, 3, 4, 5, 100),
                      reverse = TRUE)
    }    
  }
  
  lab <- paste(round(locality_map[[input$indicator]], digits = 2), 
               "%<br>", sep = "")
  
  lab[is.nan(locality_map[[input$indicator]])] <- "No discharges<br>"
  
  lab[!is.nan(locality_map[[input$indicator]]) & is.na(locality_map[[input$indicator]])] <- "No data<br>"

  leafletProxy("localityPerformanceMap") %>%
    clearControls() %>%
    clearShapes() %>%
    fitBounds(lng1 = bbox(locality_map)[1, 1], lat1 = bbox(locality_map)[2, 1],
              lng2 = bbox(locality_map)[1, 2], lat2 = bbox(locality_map)[2, 2]) %>%
    addPolygons(data = locality_map,
                fillColor = pal(locality_map[[input$indicator]]),
                weight = 2,
                opacity = 1,
                color = pal(locality_map[[input$indicator]]),
                dashArray = "",
                fillOpacity = 0.8,
                highlight = highlightOptions(weight = 3,
                                             color = "#666",
                                             dashArray = "",
                                             fillOpacity = 0.7,
                                             bringToFront = TRUE),
                label = paste("<strong>", locality_map[["Name_Engli"]], 
                              " Locality</strong><br/><strong>", 
                              locality_map[["State_En"]], 
                              " State</strong><br/><strong>", indicator,
                              ":</strong> ", 
                              lab, input$chosen_month, " ", 
                              input$chosen_year, sep = "") %>%
                  lapply(FUN = htmltools::HTML),
                labelOptions = labelOptions(style = list("font-weight" = "normal", 
                                                         padding = "3px 8px"),
                                            textsize = "12px",
                                            direction = "auto")) %>%
    addLegend(pal = pal, 
              values = c(0, 100),
              title = htmltools::HTML(
                paste(indicator, "<br/>", 
                      input$state_name, " State<br/>",
                      input$chosen_month, 
                      " ",  input$chosen_year, sep = "")),
              opacity = 0.7,
              position = "bottomright", 
              labFormat = legend.format(digits = 1, between = " to ", suffix = "%"),
              layerId = "legend")
})

observeEvent(input$chosen_year, {
  xx <- monitoring %>% 
    filter(Year == input$chosen_year,
           Month == input$chosen_month,
           State == input$state_name) %>%
    calculate_performance() %>%
    mutate(cured_perc = cured_prop * 100,
           defaulted_perc = defaulter_prop * 100,
           dead_perc = dead_prop * 100,
           nonresponder_perc = nr_prop * 100,
           Month = factor(x = Month, 
                          levels = month.abb))  
  
  locality_map <- localities
  locality_map <- subset(locality_map, State_En == input$state_name)
  locality_map@data <- merge(locality_map@data, xx, 
                             by.x = "Name_Engli", 
                             by.y = "Locality",
                             all.x = TRUE)
    
  locality_map@data <- locality_map@data[order(as.numeric(locality_map$OBJECTID)), ]
    
  if(input$indicator == "cured_perc") {
    indicator <- "Cured"
    mapPalette <- brewer.pal(n = 6, name = "RdYlGn")
    pal <- colorBin(palette = mapPalette,
                    domain = c(0, 100),
                    bins = c(0, 75, 80, 85, 90, 95, 100))
  } else {
    mapPalette <- brewer.pal(n = 5, name = "RdYlGn")
    
    if(input$indicator == "defaulted_perc") {
      indicator <- "Defaulted"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 1, 5, 10, 15, 100),
                      reverse = TRUE)
    }
    
    if(input$indicator == "dead_perc") {
      indicator <- "Dead"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 2, 5, 8, 10, 100),
                      reverse = TRUE)
    }  
  
    if(input$indicator == "nonresponder_perc") {
      indicator <- "Non-responder"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 2, 3, 4, 5, 100),
                      reverse = TRUE)
    }    
  }
  
  lab <- paste(round(locality_map[[input$indicator]], digits = 2), 
               "%<br>", sep = "")
  
  lab[is.nan(locality_map[[input$indicator]])] <- "No discharges<br>"
  
  lab[!is.nan(locality_map[[input$indicator]]) & is.na(locality_map[[input$indicator]])] <- "No data<br>"
  
  leafletProxy("localityPerformanceMap") %>%
    clearControls() %>%
    clearShapes() %>%
    fitBounds(lng1 = bbox(locality_map)[1, 1], lat1 = bbox(locality_map)[2, 1],
              lng2 = bbox(locality_map)[1, 2], lat2 = bbox(locality_map)[2, 2]) %>%
    addPolygons(data = locality_map,
                fillColor = pal(locality_map[[input$indicator]]),
                weight = 2,
                opacity = 1,
                color = pal(locality_map[[input$indicator]]),
                dashArray = "",
                fillOpacity = 0.8,
                highlight = highlightOptions(weight = 3,
                                             color = "#666",
                                             dashArray = "",
                                             fillOpacity = 0.7,
                                             bringToFront = TRUE),
                label = paste("<strong>", locality_map[["Name_Engli"]], 
                              " Locality</strong><br/><strong>", 
                              locality_map[["State_En"]], 
                              " State</strong><br/><strong>", indicator,
                              ":</strong> ", 
                              lab, input$chosen_month, " ", 
                              input$chosen_year, sep = "") %>%
                  lapply(FUN = htmltools::HTML),
                labelOptions = labelOptions(style = list("font-weight" = "normal", 
                                                         padding = "3px 8px"),
                                            textsize = "12px",
                                            direction = "auto")) %>%
    addLegend(pal = pal, 
              values = c(0, 100),
              title = htmltools::HTML(
                paste(indicator, "<br/>", 
                      input$state_name, " State<br/>",
                      input$chosen_month, 
                      " ",  input$chosen_year, sep = "")),
              opacity = 0.7,
              position = "bottomright", 
              labFormat = legend.format(digits = 1, between = " to ", suffix = "%"),
              layerId = "legend")
})

observeEvent(input$state_name, {
  xx <- monitoring %>% 
    filter(Year == input$chosen_year,
           Month == input$chosen_month,
           State == input$state_name) %>%
    calculate_performance() %>%
    mutate(cured_perc = cured_prop * 100,
           defaulted_perc = defaulter_prop * 100,
           dead_perc = dead_prop * 100,
           nonresponder_perc = nr_prop * 100,
           Month = factor(x = Month, 
                          levels = month.abb))  
  
  locality_map <- localities
  locality_map <- subset(locality_map, State_En == input$state_name)
  locality_map@data <- merge(locality_map@data, xx, 
                             by.x = "Name_Engli", 
                             by.y = "Locality",
                             all.x = TRUE)
    
  locality_map@data <- locality_map@data[order(as.numeric(locality_map$OBJECTID)), ]
    
  if(input$indicator == "cured_perc") {
    indicator <- "Cured"
    mapPalette <- brewer.pal(n = 6, name = "RdYlGn")
    pal <- colorBin(palette = mapPalette,
                    domain = c(0, 100),
                    bins = c(0, 75, 80, 85, 90, 95, 100))
  } else {
    mapPalette <- brewer.pal(n = 5, name = "RdYlGn")
    
    if(input$indicator == "defaulted_perc") {
      indicator <- "Defaulted"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 1, 5, 10, 15, 100),
                      reverse = TRUE)
    }
    
    if(input$indicator == "dead_perc") {
      indicator <- "Dead"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 2, 5, 8, 10, 100),
                      reverse = TRUE)
    }  
  
    if(input$indicator == "nonresponder_perc") {
      indicator <- "Non-responder"
      pal <- colorBin(palette = mapPalette,
                      domain = c(0, 100),
                      bins = c(0, 2, 3, 4, 5, 100),
                      reverse = TRUE)
    }    
  }
  
  lab <- paste(round(locality_map[[input$indicator]], digits = 2), 
               "%<br>", sep = "")
  
  lab[is.nan(locality_map[[input$indicator]])] <- "No discharges<br>"
  
  lab[!is.nan(locality_map[[input$indicator]]) & is.na(locality_map[[input$indicator]])] <- "No data<br>"
  
  leafletProxy("localityPerformanceMap") %>%
    clearControls() %>%
    clearShapes() %>%
    fitBounds(lng1 = bbox(locality_map)[1, 1], lat1 = bbox(locality_map)[2, 1],
              lng2 = bbox(locality_map)[1, 2], lat2 = bbox(locality_map)[2, 2]) %>%
    addPolygons(data = locality_map,
                fillColor = pal(locality_map[[input$indicator]]),
                weight = 2,
                opacity = 1,
                color = pal(locality_map[[input$indicator]]),
                dashArray = "",
                fillOpacity = 0.8,
                highlight = highlightOptions(weight = 3,
                                             color = "#666",
                                             dashArray = "",
                                             fillOpacity = 0.7,
                                             bringToFront = TRUE),
                label = paste("<strong>", locality_map[["Name_Engli"]], 
                              " Locality</strong><br/><strong>", 
                              locality_map[["State_En"]], 
                              " State</strong><br/><strong>", indicator,
                              ":</strong> ", 
                              lab, input$chosen_month, " ", 
                              input$chosen_year, sep = "") %>%
                  lapply(FUN = htmltools::HTML),
                labelOptions = labelOptions(style = list("font-weight" = "normal", 
                                                         padding = "3px 8px"),
                                            textsize = "12px",
                                            direction = "auto")) %>%
    addLegend(pal = pal, 
              values = c(0, 100),
              title = htmltools::HTML(
                paste(indicator, "<br/>", 
                      input$state_name, " State<br/>",
                      input$chosen_month, 
                      " ",  input$chosen_year, sep = "")),
              opacity = 0.7,
              position = "bottomright", 
              labFormat = legend.format(digits = 1, between = " to ", suffix = "%"),
              layerId = "legend")
})

leafletOutput(outputId = "localityPerformanceMap")
```

Responsiveness
================================================================================

Row {.tabset .tabset-fade}
--------------------------------------------------------------------------------

### Admissions - National

```{r, fig.height = 5}
overall_admissions_defaulters <- reactive({
  aggregate(cbind(`New Admissions`, Default) ~ Month + Year, 
            data = monitoring, FUN = sum) %>% 
    mutate(MonthYear = as.Date(paste(Year, Month, "01", sep = "-"), format = "%Y-%b-%d")) %>%
    arrange(MonthYear) %>%
    mutate(`Admissions (smoothed)` = smooth_m3a3(x = `New Admissions`),
           `Defaulters (smoothed)` = smooth_m3a3(x = Default))
})

season_long <- reactive({
  seasonal_calendar %>%
    mutate(startmy = paste(month.abb[month(as.Date(start))], year(as.Date(start))),
           endmy = paste(month.abb[month(as.Date(end))], year(as.Date(end))))
})

output$overall_admissions <- renderPlotly({
  z <- overall_admissions_defaulters() %>%
    ggplot() +
    geom_line(mapping = aes(x = MonthYear, y = `New Admissions`, group = 1,
                            text = paste(Month, " ", Year, "\nNew Admissions: ", 
                                         `New Admissions`, sep = "")),
              colour = "blue", linetype = 1, size = 2)
  
  if(input$smooth) {
    z <- z +
      geom_line(mapping = aes(x = MonthYear, y = `Admissions (smoothed)`, group = 1,
                              text = "Admissions (smoothed)"),
                colour = "blue", alpha = 0.5, linetype = 1, size = 2)
  }
  
  if(input$showCalendar) {
    z <- z +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 0, ymax = 2000, fill = group,
                              text = event),
                data = season_long() %>% filter(group == "Food availability"),
                alpha = 0.25) +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 2500, ymax = 4500, fill = group,
                              text = event),
                data = season_long() %>% filter(group == "Planting"),
                alpha = 0.25) +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 5000, ymax = 7000, fill = group,
                              text = event),
                data = season_long() %>% filter(group == "Rainfall"),
                alpha = 0.25)
  }
  
  z <- z + 
    scale_y_continuous(limits = c(0, max(overall_admissions_defaulters()[["New Admissions"]])),
                       breaks = seq(from = 0, 
                                    to = max(overall_admissions_defaulters()[["New Admissions"]]),
                                    by = 5000)) +
    scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
    labs(title = "Admissions over time - 2016 to 2019", x = "") +
    unicef_theme +
    theme(axis.text.x = element_text(size = 8, angle = 90),
          axis.text.y = element_text(size = 8))

  ggplotly(p = z, tooltip = "text") %>%
    layout(legend = list(orientation = "h", y = 1.075))
})

plotlyOutput(outputId = "overall_admissions")
```

### Admissions - State

```{r, fig.height = 5}
overall_state_admissions_defaulters <- reactive({
  aggregate(cbind(`New Admissions`, Default) ~ State + Month + Year, 
            data = monitoring, FUN = sum) %>%
    filter(State == input$state_name) %>%
    mutate(MonthYear = as.Date(paste(Year, Month, "01", sep = "-"), format = "%Y-%b-%d")) %>%
    arrange(MonthYear) %>%
    mutate(`Admissions (smoothed)` = smooth_m3a3(x = `New Admissions`),
           `Defaulters (smoothed)` = smooth_m3a3(x = Default))
})

output$overall_state_admissions <- renderPlotly({
  z <- overall_state_admissions_defaulters() %>%
    ggplot() +
    geom_line(mapping = aes(x = MonthYear, y = `New Admissions`, group = 1,
                            text = paste(Month, " ", Year, "\nNew Admissions: ", 
                                         round(`New Admissions`, digits = 1), sep = "")), 
              colour = "blue", linetype = 1, size = 2)

  if(input$smooth) {
    z <- z +
      geom_line(mapping = aes(x = MonthYear, y = `Admissions (smoothed)`,
                              text = "Admissions (smoothed)"), 
                colour = "blue", alpha = 0.5, linetype = 1, size = 2)
  }
  
  if(input$showCalendar) {
    z <- z +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 0, ymax = 100, fill = group,
                              text = event),
                data = season_long() %>% filter(group == "Food availability"),
                alpha = 0.25) +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 150, ymax = 250, fill = group,
                              text = event),
                data = season_long() %>% filter(group == "Planting"),
                alpha = 0.25) +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 300, ymax = 400, fill = group,
                              text = event),
                data = season_long() %>% filter(group == "Rainfall"),
                alpha = 0.25)
  }
  
  z <- z + 
    scale_y_continuous(limits = c(0, max(overall_state_admissions_defaulters()[["New Admissions"]]))) +
    scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
    labs(title = paste("Admissions over time - 2016 to 2019 - ", 
                       input$state_name, " State", sep = ""), 
         x = "") +
    unicef_theme +
    theme(axis.text.x = element_text(size = 8, angle = 90),
          axis.text.y = element_text(size = 8))
  
  ggplotly(p = z, tooltip = "text") %>%
    layout(legend = list(orientation = "h", y = 1.075))
})

plotlyOutput(outputId = "overall_state_admissions")
```

### Admissions - Locality

```{r, fig.height = 5}
overall_locality_admissions_defaulters <- reactive({
  req(input$locality_name)
  monitoring %>%
    filter(State == input$state_name,
           Locality == input$locality_name) %>%
    mutate(MonthYear = as.Date(paste(Year, Month, "01", sep = "-"), format = "%Y-%b-%d")) %>%
    arrange(MonthYear) %>%
    mutate(`Admissions (smoothed)` = smooth_m3a3(x = `New Admissions`),
           `Defaulters (smoothed)` = smooth_m3a3(x = Default))
})

output$overall_locality_admissions <- renderPlotly({
  z <- overall_locality_admissions_defaulters() %>%
    ggplot() +
    geom_line(mapping = aes(x = MonthYear, y = `New Admissions`, group = 1,
                            text = paste(Month, " ", Year, "\nNew Admissions: ", 
                                         `New Admissions`, sep = "")), 
              colour = "blue", linetype = 1, size = 2)

  if(input$smooth) {
    z <- z +
      geom_line(mapping = aes(x = MonthYear, y = `Admissions (smoothed)`,
                              text = "Admissions (smoothed)"), 
                colour = "blue", alpha = 0.5, linetype = 1, size = 2)
  }
  
  if(input$showCalendar) {
    z <- z +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 0, ymax = 7.5, fill = group,
                              text = event),
                data = season_long() %>% filter(group == "Food availability"),
                alpha = 0.25) +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 10, ymax = 17.5, fill = group,
                              text = event),
                data = season_long() %>% filter(group == "Planting"),
                alpha = 0.25) +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 20, ymax = 27.5, fill = group,
                              text = event),
                data = season_long() %>% filter(group == "Rainfall"),
                alpha = 0.25)
  }  
  
  z <- z +
    scale_y_continuous(limits = c(0, max(overall_locality_admissions_defaulters()[["New Admissions"]]))) +
    scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
    labs(title = paste("Admissions over time - 2016 to 2019 - ",
                       input$locality_name, " Locality, ",
                       input$state_name, " State", sep = ""), 
                       x = "") +
    unicef_theme +
    theme(axis.text.x = element_text(size = 8, angle = 90),
          axis.text.y = element_text(size = 8))
  
  ggplotly(p = z, tooltip = "text") %>%
    layout(legend = list(orientation = "h", y = 1.075))
})

plotlyOutput(outputId = "overall_locality_admissions")
```

Row {.tabset .tabset-fade}
--------------------------------------------------------------------------------

### Defaulters - National

```{r, fig.height = 5}
output$overall_defaulters <- renderPlotly({
  z <- overall_admissions_defaulters() %>%
    ggplot() +
    geom_line(mapping = aes(x = MonthYear, y = Default, group = 1,
                            text = paste(Month, " ", Year, 
                                         "\nDefaulters: ", Default, sep = "")), 
              colour = "red", linetype = 1, size = 2)

  if(input$smooth) {
    z <- z +
      geom_line(mapping = aes(x = MonthYear, y = `Defaulters (smoothed)`,
                              text = "Defaulters (smoothed)"), 
                colour = "red", alpha = 0.5, linetype = 1, size = 2)
  }
  
  if(input$showCalendar) {
    z <- z +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 0, ymax = 175, fill = group,
                              text = event),
                data = season_long() %>% filter(group == "Food availability"),
                alpha = 0.25) +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 225, ymax = 400, fill = group,
                              text = event),
                data = season_long() %>% filter(group == "Planting"),
                alpha = 0.25) +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 450, ymax = 625, fill = group,
                              text = event),
                data = season_long() %>% filter(group == "Rainfall"),
                alpha = 0.25)
  }
  
  z <- z + 
    scale_y_continuous(limits = c(0, max(overall_admissions_defaulters()[["Default"]])),
                       breaks = seq(from = 0, 
                                    to = max(overall_admissions_defaulters()[["Default"]]),
                                    by = 500)) +
    scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
    labs(title = "Defaulters over time - 2016 to 2019", x = "") +
    unicef_theme +
    theme(axis.text.x = element_text(size = 8, angle = 90),
          axis.text.y = element_text(size = 8))
  
  ggplotly(p = z, tooltip = "text") %>%
    layout(legend = list(orientation = "h", y = 1.075))
})

plotlyOutput(outputId = "overall_defaulters")
```

### Defaulters - State

```{r, fig.height = 5}
output$overall_state_defaulters <- renderPlotly({
  z <- overall_state_admissions_defaulters() %>%
    ggplot() +
    geom_line(mapping = aes(x = MonthYear, y = Default, group = 1,
                            text = paste(Month, " ", Year, 
                                         "\nDefaulters: ", Default, sep = "")), 
              colour = "red", linetype = 1, size = 2)

  if(input$smooth) {
    z <- z +
      geom_line(mapping = aes(x = MonthYear, y = `Defaulters (smoothed)`,
                              text = "Defaulters (smoothed)"), 
                colour = "red", alpha = 0.5, linetype = 1, size = 2)
  }
  
  if(input$showCalendar) {
    z <- z +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 0, ymax = 20, fill = group,
                              text = event),
                data = season_long() %>% filter(group == "Food availability"),
                alpha = 0.25) +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 25, ymax = 45, fill = group,
                              text = event),
                data = season_long() %>% filter(group == "Planting"),
                alpha = 0.25) +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 50, ymax = 70, fill = group,
                              text = event),
                data = season_long() %>% filter(group == "Rainfall"),
                alpha = 0.25)
  }  
  
  z <- z + 
    scale_y_continuous(limits = c(0, max(overall_state_admissions_defaulters()[["Default"]]))) +
    scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
    labs(title = paste("Defaulters over time - 2016 to 2019 - ", 
                       input$state_name, " State", sep = ""),
                       x = "") + 
    unicef_theme +
    theme(axis.text.x = element_text(size = 8, angle = 90),
          axis.text.y = element_text(size = 8))
  
  ggplotly(p = z, tooltip = "text") %>%
    layout(legend = list(orientation = "h", y = 1.075))
})

plotlyOutput(outputId = "overall_state_defaulters")
```

### Defaulters - Locality

```{r, fig.height = 5}
output$overall_locality_defaulters <- renderPlotly({
  z <- overall_locality_admissions_defaulters() %>%
    ggplot() +
    geom_line(mapping = aes(x = MonthYear, y = Default, group = 1,
                            text = paste(Month, " ", Year, 
                                         "\nDefaulters: ", Default, sep = "")), 
              colour = "red", linetype = 1, size = 2)

  if(input$smooth) {
    z <- z +
      geom_line(mapping = aes(x = MonthYear, y = `Defaulters (smoothed)`,
                              text = "Defaulters (smoothed)"), 
                colour = "red", alpha = 0.5, linetype = 1, size = 2)
  }
  
  if(input$showCalendar) {
    z <- z +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 0, ymax = 5, fill = group,
                              text = event),
                data = season_long() %>% filter(group == "Food availability"),
                alpha = 0.25) +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 7.5, ymax = 12.5, fill = group,
                              text = event),
                data = season_long() %>% filter(group == "Planting"),
                alpha = 0.25) +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 15, ymax = 20, fill = group,
                              text = event),
                data = season_long() %>% filter(group == "Rainfall"),
                alpha = 0.25)
  }  
  
  z <- z + 
    scale_y_continuous(limits = c(0, max(overall_locality_admissions_defaulters()[["Default"]]))) +
    scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
    labs(title = paste("Defaulters over time - 2016 to 2019 - ",
                       input$locality_name, " Locality, ",
                       input$state_name, " State", sep = ""), 
                       x = "") +
    unicef_theme +
    theme(axis.text.x = element_text(size = 8, angle = 90),
          axis.text.y = element_text(size = 8))
  
  ggplotly(p = z, tooltip = "text") %>%
    layout(legend = list(orientation = "h", y = 1.075))
})

plotlyOutput(outputId = "overall_locality_defaulters")
```

Row {.tabset .tabset-fade}
--------------------------------------------------------------------------------

### Admissions - National

```{r, fig.height = 8}
admissions_defaulters <- reactive({
  aggregate(cbind(`New Admissions`, Default) ~ Month + Year, 
            data = monitoring, FUN = sum) %>% 
    filter(Year == input$chosen_year) %>%
    mutate(Month = factor(x = Month, 
                          levels = month.abb),
           MonthYear = as.Date(paste(Year, Month, "01", sep = "-"), format = "%Y-%b-%d")) %>%
    arrange(MonthYear) %>%
    mutate(`Admissions (smoothed)` = smooth_m3a3(x = `New Admissions`),
           `Defaulters (smoothed)` = smooth_m3a3(x = Default))
})

season_year <- reactive({
  seasonal_calendar %>%
    mutate(startmy = paste(month.abb[month(as.Date(start))], year(as.Date(start))),
           endmy = paste(month.abb[month(as.Date(end))], year(as.Date(end)))) %>%
    filter(year(as.Date(start)) == input$chosen_year)
})

output$admissions <- renderPlotly({
  z <- admissions_defaulters() %>%
    ggplot() +
    geom_line(mapping = aes(x = MonthYear, y = `New Admissions`, group = Year,
                            text = paste(Month, " ", Year, 
                                         "\nNew Admissions: ", `New Admissions`, sep = "")), 
              colour = "blue", linetype = 1, size = 2)

  if(input$smooth) {
    z <- z +
      geom_line(mapping = aes(x = MonthYear, y = `Admissions (smoothed)`,
                              text = "Admissions (smoothed)"), 
                colour = "blue", alpha = 0.5, linetype = 1, size = 2)
  }

  if(input$showCalendar) {
    z <- z +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 0, ymax = 2500, fill = group,
                              text = event),
                data = season_year() %>% filter(group == "Food availability"),
                alpha = 0.25) +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 3500, ymax = 6000, fill = group,
                              text = event),
                data = season_year() %>% filter(group == "Planting"),
                alpha = 0.25) +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 7000, ymax = 9500, fill = group,
                              text = event),
                data = season_year() %>% filter(group == "Rainfall"),
                alpha = 0.25)
  }  
    
  z <- z +
    scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
    scale_y_continuous(limits = c(0, max(admissions_defaulters()[["New Admissions"]])),
                       breaks = seq(from = 0, 
                                    to = max(admissions_defaulters()[["New Admissions"]]),
                                    by = 5000)) +
    labs(title = paste("Admissions over time - Year ", input$chosen_year, sep = ""),
         x = "") +
    unicef_theme
  
  ggplotly(p = z, tooltip = "text") %>%
    layout(legend = list(orientation = "h", y = 1.04))
})

plotlyOutput(outputId = "admissions")
```

### Admissions - State

```{r, fig.height = 8}
state_admissions_defaulters <- reactive({
  aggregate(cbind(`New Admissions`, Default) ~ State + Month + Year, 
            data = monitoring, FUN = sum) %>% 
    filter(Year == input$chosen_year) %>%
    mutate(Month = factor(x = Month, 
                          levels = month.abb)) %>%
    group_by(State) %>%
    arrange(Month, .by_group = TRUE) %>%
    mutate(`Admissions (smoothed)` = smooth_m3a3(x = `New Admissions`),
           `Defaulters (smoothed)` = smooth_m3a3(x = Default))
})

output$state_admissions <- renderPlotly({
  z <- state_admissions_defaulters() %>%
    ggplot(mapping = aes(x = Month, group = State)) +
    geom_line(mapping = aes(y = `New Admissions`), colour = "blue", size = 1) +
    labs(title = paste("Admissions over time by state - Year ", input$chosen_year, sep = ""),
         x = "") +
    facet_wrap( ~ State, ncol = 6, scales = input$scales)
      
  if(input$smooth) {
    z <- z +
      geom_line(mapping = aes(y = `Admissions (smoothed)`), 
                colour = "blue", alpha = 0.5, linetype = 2, size = 1)
  }

  if(input$scales == "fixed") {
   z <- z +
    scale_y_continuous(limits = c(0, max(state_admissions_defaulters()[["New Admissions"]])),
                       breaks = seq(from = 0, 
                                    to = max(state_admissions_defaulters()[["New Admissions"]]),
                                    by = 1000))
  }
  
  z <- z +
    unicef_theme +
    theme(axis.text.x = element_text(size = 8, angle = 90),
          axis.text.y = element_text(size = 8))
  
  ggplotly(p = z)
})

plotlyOutput(outputId = "state_admissions")
```

### Admissions - Locality

```{r, fig.height = 8}
locality_admissions_defaulters <- reactive({
  monitoring %>% 
    filter(Year == input$chosen_year,
           State == input$state_name) %>%
    mutate(Month = factor(x = Month, 
                          levels = month.abb)) %>%
    group_by(Locality) %>%
    arrange(Month, .by_group = TRUE) %>%
    mutate(`Admissions (smoothed)` = smooth_m3a3(x = `New Admissions`),
           `Defaulters (smoothed)` = smooth_m3a3(x = Default))
})

output$locality_admissions <- renderPlotly({
  z <- locality_admissions_defaulters() %>%
    ggplot(mapping = aes(x = Month, group = State)) +
    geom_line(mapping = aes(y = `New Admissions`), 
              colour = "blue", linetype = 1, size = 1) +
    labs(title = paste("Admissions over time in ", input$state_name, 
                       " State by locality - Year ", input$chosen_year, sep = ""),
         x = "") +
    facet_wrap( ~ Locality, nrow = 3, scale = input$scales)
  
  if(input$smooth) {
    z <- z
      geom_line(mapping = aes(y = `Admissions (smoothed)`), 
                colour = "blue", alpha = 0.5, linetype = 2, size = 1)
  }
  
  z <- z +
    unicef_theme +
    theme(axis.text.x = element_text(size = 8, angle = 90),
          axis.text.y = element_text(size = 8))
  
  ggplotly(p = z)
})

plotlyOutput(outputId = "locality_admissions")
```

Row {.tabset .tabset-fade}
--------------------------------------------------------------------------------

### Defaulters - National

```{r}
output$defaulters <- renderPlotly({
  z <- admissions_defaulters() %>%
    ggplot() +
    geom_line(mapping = aes(x = MonthYear, y = `Default`, group = Year,
                            text = paste(Month, " ", Year,
                                         "\nDefaulters: ", Default, sep = "")), 
              colour = "red", linetype = 1, size = 2)
  
  if(input$smooth) {
    z <- z +
      geom_line(mapping = aes(x = MonthYear, y = `Defaulters (smoothed)`,
                              text = "Defauters (smoothed)"), 
                colour = "red", alpha = 0.5, linetype = 1, size = 2)
  }
  
  if(input$showCalendar) {
    z <- z +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 0, ymax = 250, fill = group,
                              text = event),
                data = season_year() %>% filter(group == "Food availability"),
                alpha = 0.25) +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 350, ymax = 600, fill = group,
                              text = event),
                data = season_year() %>% filter(group == "Planting"),
                alpha = 0.25) +
      geom_rect(mapping = aes(xmin = as.Date(start), xmax = as.Date(end),
                              ymin = 700, ymax = 950, fill = group,
                              text = event),
                data = season_year() %>% filter(group == "Rainfall"),
                alpha = 0.25)
  }
  
  z <- z +
    scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
    scale_y_continuous(limits = c(0, max(admissions_defaulters()[["Default"]])),
                       breaks = seq(from = 0, 
                                    to = max(admissions_defaulters()[["Default"]]),
                                    by = 500)) +
    labs(title = paste("Defaulters over time - Year ", input$chosen_year, sep = ""),
         x = "") +
    unicef_theme
  
  ggplotly(p = z, tooltip = "text") %>%
    layout(legend = list(orientation = "h", y = 1.04))
})

plotlyOutput(outputId = "defaulters")
```

### Defaulters - State

```{r, fig.height = 8}
output$state_defaulters <- renderPlotly({
  z <- state_admissions_defaulters() %>%
    ggplot(mapping = aes(x = Month, group = State)) +
    geom_line(mapping = aes(y = Default), colour = "red", 
              linetype = 1, size = 1) +    
    labs(title = paste("Defaulters over time by state - Year ", input$chosen_year, sep = ""),
         x = "") +
    facet_wrap( ~ State, ncol = 6, scale = input$scales)  
  
  if(input$smooth) {
    z <- z +
    geom_line(mapping = aes(y = `Defaulters (smoothed)`), 
              colour = "red", alpha = 0.5, linetype = 2, size = 1)
  }
  
  if(input$scales == "fixed") {
    z <- z +
    scale_y_continuous(limits = c(0, max(state_admissions_defaulters()[["Default"]])),
                       breaks = seq(from = 0, 
                                    to = max(state_admissions_defaulters()[["Default"]]),
                                    by = 100))
  }
  
  z <- z +
    unicef_theme +
    theme(axis.text.x = element_text(size = 8, angle = 90),
          axis.text.y = element_text(size = 8))
  
  ggplotly(p = z)
})

plotlyOutput(outputId = "state_defaulters")
```

### Defaulters - Locality

```{r, fig.height = 8}
output$locality_defaulters <- renderPlotly({
  z <- locality_admissions_defaulters() %>%
    ggplot(mapping = aes(x = Month, group = State)) +
    geom_line(mapping = aes(y = Default), 
              colour = "red", linetype = 1, size = 1) +
    labs(title = paste("Defaulters over time in ", input$state_name,
                       " State by locality - Year ", input$chosen_year, sep = ""),
         x = "") +
    facet_wrap( ~ Locality, nrow = 3, scale = input$scales)  
  
  if(input$smooth) {
      z <- z +
        geom_line(mapping = aes(y = `Defaulters (smoothed)`), 
                  colour = "red", alpha = 0.5, linetype = 2, size = 1)
  }
  
  z <- z +
    unicef_theme +
    theme(axis.text.x = element_text(size = 8, angle = 90),
          axis.text.y = element_text(size = 8))
  
  ggplotly(p = z)
})

plotlyOutput(outputId = "locality_defaulters")
```


Case-finding
================================================================================

```{r muac1}
## Tidy the list
x1 <- muac_admission[[1]] %>%
  pivot_longer(cols = `Tahdi Osisi`:Baryay, 
               names_to = "health_facilities", 
               values_to = "n")

x2 <- muac_admission[[2]] %>%
  pivot_longer(cols = `Alhara alula`:Omrahaw, 
               names_to = "health_facilities", 
               values_to = "n")

x3 <- muac_admission[[3]] %>%
  pivot_longer(cols = `Mukram`:`Al Kuaty hospital`, 
               names_to = "health_facilities", 
               values_to = "n")

x4 <- muac_admission[[4]] %>%
  pivot_longer(cols = `8 - Arab`:`Reara`, 
               names_to = "health_facilities", 
               values_to = "n")

## Concatenate
xx <- rbind(x1, x2, x3, x4)
```

Row <!--- {.tabset .tabset-fade} --->
--------------------------------------------------------------------------------

### By state

```{r muac2, fig.height = 6}
muac_state <- aggregate(n ~ state + muac, data = xx, FUN = sum)

median_muac <- muac_state %>%
  split(f = muac_state$state) %>%
  lapply(FUN = function(x) median(rep(x$muac, x$n), na.rm = TRUE)) %>%
  unlist()

median_muac <- names(median_muac) %>%
  data.frame(median_muac)

names(median_muac) <- c("state", "median muac")
row.names(median_muac) <- 1:nrow(median_muac)
  
output$state_muac <- renderPlotly({
  z <- muac_state %>%
    ggplot(mapping = aes(x = muac, y = n)) +
    geom_col(fill = unicef_blue, alpha = 0.7) +
    geom_vline(data = median_muac,
               mapping = aes(xintercept = `median muac`), 
               colour = unicef_darkblue, 
               linetype = 2, size = 0.5) +
    scale_x_reverse(breaks = seq(from = 115, to = 60, by = -5)) +
    labs(title = "MUAC at Admission by State", x = "MUAC (mm)") +
    facet_wrap(. ~ state, ncol = 3) +
    unicef_theme
  
  ggplotly(p = z)
})

plotlyOutput(outputId = "state_muac")
```

Row
--------------------------------------------------------------------------------

### By locality

```{r muac3, fig.height = 8}
muac_locality <- aggregate(n ~ state + locality + muac, data = xx, FUN = sum)

median_muac_locality <- muac_locality %>%
  split(f = list(muac_locality$state, muac_locality$locality)) %>%
  lapply(FUN = function(x) median(rep(x$muac, x$n), na.rm = TRUE)) %>%
  unlist()


median_muac_locality <- stringr::str_split(string = names(median_muac_locality), 
                                           pattern = "\\.", 
                                           simplify = TRUE) %>%
  data.frame(median_muac_locality) %>%
  rename(state = X1, locality = X2, `median muac` = median_muac_locality)

row.names(median_muac_locality) <- 1:nrow(median_muac_locality)

output$locality_muac <- renderPlotly({
  z <- muac_locality %>%
    ggplot(mapping = aes(x = muac, y = n)) +
    geom_col(fill = unicef_blue, alpha = 0.7) +
    geom_vline(data = median_muac_locality,
               mapping = aes(xintercept = `median muac`), 
               colour = unicef_darkblue, 
               linetype = 2, size = 0.5) +
    scale_x_reverse(breaks = seq(from = 115, to = 60, by = -5)) +
    labs(title = "MUAC at Admission by Locality", x = "MUAC (mm)") +
    facet_grid(locality ~ state) +
    unicef_theme
  
  ggplotly(p = z)
})

plotlyOutput(outputId = "locality_muac")
```

Effectiveness
================================================================================

Row {.tabset .tabset-fade}
--------------------------------------------------------------------------------

```{r los1}
length_of_stay <- otp_beneficiaries %>%
  calculate_los_df(admission_date = "admDate", discharge_date = "disDate") %>%
  mutate(state = "Kassala") %>%
  dplyr::relocate(state, .before = locality)

median_los_state <- length_of_stay %>%
  split(f = length_of_stay$state) %>%
  lapply(FUN = function(x) median(x$los, na.rm = TRUE)) %>%
  unlist()

median_los_state <- names(median_los_state) %>%
  data.frame(median_los_state)

names(median_los_state) <- c("state", "median length-of-stay")
row.names(median_los_state) <- 1:nrow(median_los_state)

median_los_locality <- length_of_stay %>%
  split(f = list(length_of_stay$state, length_of_stay$locality)) %>%
  lapply(FUN = function(x) median(x$los, na.rm = TRUE)) %>%
  unlist()

median_los_locality <- stringr::str_split(string = names(median_los_locality), 
                                          pattern = "\\.", 
                                          simplify = TRUE) %>%
  data.frame(median_los_locality) %>%
  rename(state = X1, locality = X2, `median length-of-stay` = median_los_locality)

row.names(median_los_locality) <- 1:nrow(median_los_locality)
```

### By state

```{r los2, fig.height = 8}
output$los_state <- renderPlotly({
  los_state_plot <- length_of_stay %>%
    ggplot(mapping = aes(x = state, y = los)) +
    geom_boxplot(colour = unicef_blue, width = 0.5) +
    labs(title = "Median length-of-stay by state",
         x = "",
         y = "Length-of-stay (days)") +
    unicef_theme
  
  ggplotly(p = los_state_plot)
})

plotlyOutput(outputId = "los_state")
```

### By locality

```{r los3, fig.height = 8}
output$los_locality <- renderPlotly({
  los_locality_plot <- length_of_stay %>%
    ggplot(mapping = aes(x = locality, y = los)) +
    geom_boxplot(colour = unicef_blue, width = 0.5) +
    labs(title = "Median length-of-stay by locality",
         x = "",
         y = "Length-of-stay (days)") +
    facet_wrap(state ~ .) +
    unicef_theme
  
  ggplotly(p = los_locality_plot)
})

plotlyOutput(outputId = "los_locality")
```

Row {.tabset .tabset-fade}
--------------------------------------------------------------------------------

```{r wtGain1}
wt_gain <- otp_beneficiaries %>%
  mutate(state = "Kassala") %>%
  dplyr::relocate(state, .before = locality) %>%
  calculate_los_df(admission_date = "admDate", discharge_date = "disDate") %>%
  mutate(wtGain = ((diswt - wt) * 1000) / (wt * los)) %>%
  filter(wtGain >= 0)
```

### By state

```{r wtGain2, fig.height = 8}
output$wt_gain_state <- renderPlotly({
  z <- wt_gain %>%
    ggplot(mapping = aes(x = state, y = wtGain)) +
    geom_boxplot(colour = unicef_blue, width = 0.5) +
    labs(title = "Average weight gain by state",
         x = "",
         y = "Average weight gain (g/kg/day)") +
    unicef_theme
  
  ggplotly(p = z)
})

plotlyOutput(outputId = "wt_gain_state")
```

### By locality

```{r wtGain3, fig.height = 8}
output$wt_gain_locality <- renderPlotly({
  z <- wt_gain %>%
    ggplot(mapping = aes(x = locality, y = wtGain)) +
    geom_boxplot(colour = unicef_blue, width = 0.5) +
    labs(title = "Average weight gain by locality",
         x = "",
         y = "Average weight gain (g/kg/day)") +
    facet_wrap(state ~ .) +
    unicef_theme
  
  ggplotly(p = z)
})

plotlyOutput(outputId = "wt_gain_locality")
```


About
================================================================================

**About**

This dashboard has been developed in support of the evaluation of the **Sudan Community-based Management of Acute Malnutrition**. It presents visualisation and analysis of the national programme's routine monitoring data from 2016-2019.

<br>

**How to use the dashboard**

This dashboard has four main sections - *Performance*, *Responsiveness*, *Case-finding*, and *Effectiveness* - which can be accessed via the header tabs. The *Performance* section (shown on dashboard startup) presents analysis and visualisation of CMAM performance indicators at national, state and locality level across various time periods. The *Responsiveness* section presents analysis and visualisation of CMAM responsiveness indicators at national, state and locality level across various time periods. The *Case-finding* section shows MUAC-at-admission which is an indicator of how good the case-finding mechanism of the programme is - the closer the MUAC-at-admissions are to the admitting MUAC threshold (i.e. 115 mm) the earlier that they are found in the community and the earlier the cases are found the better their treatment outcomes are. The *Effectiveness* section presents indicators of length-of-stay in the programme and average weight gain. These indicators assess clinical effectiveness. The dashboard has a fixed sidebar that contains various user interfaces for selecting appropriate settings for respective sections. The various settings groups include an info button which when clicked shows a modal dialog box providing information and guidance on how to choose appropriate settings.

<br>

**Authors**

This dashboard has been developed by [Emmanuel Mandalazi](https://katilingban.io/author/emmanuel-mandalazi/) and [Ernest Guevarra](https://ernest.guevarra.io). This dashboard and its source code is made available under a [GPL-3 license](https://github.com/katilingban/sudanCMAM/blob/master/LICENSE.md).

